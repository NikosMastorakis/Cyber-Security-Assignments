FIRST NAME: NIKOLAOS
LAST NAME: MASTORAKIS

TASK F Answer:
Both  hpy414_verifyme_128.txt and  hpy414_verifyme_256.txt where NOT VERIFIED.

All the the Tasks from this assigment where implemented successfully.

Purpose of this assigment was to get familiar with OpenSSL toolkit  and symmetric key cryptography since the implementation contains encryption decryption using AES ECB using keys of 128 bit and 256 size.In this assignment I also implemented CMAC signing and certification functionality.

Functions declaration and usage:

long int findSize(char * ):
This function was used to get the file size that I wanted to read.The reason I created this function is to get the file size of the encrypted files in decrypt() function and before_verify_cmac() function.I also used this function In the gen_cmac() function to get the plaintext of a file when I wanted to generate its CMAC.To get to the end of the file at that function I used the fseek to traverse to the end and then with ftell() I got the final size of the file.

unsigned char* returnPlainText(char * input_file):
This function was used to get the plain text of a file.The reason I created this file was to get file content in encrypt(),decrypt() ,cgen_mac() and before_verify_cmac() functions when needed.The reason I used calloc() in this function was to because I wanted to initialize the allocated memory block to zero while reading from the files the characters since I didnt know file size.

voi keygen(unsigned char*,unsigned char*,unsigned char*,int bit_mode):
This function was responsible for the key generation of 128 or 256 bits for AES_ecb algorythm.Inside this function the key was generated by using EVP_BytesToKey usign the AES 128 or 256 ecb and sha1 hashes

unsigned char * encrypt(unsigned char*, char *,  char *, unsigned char *, 
    unsigned char *, int,int * ):This function was used to encrypt a given plaintext.At first I check If I want to open and read a file to get the plaintext and then encrypt it or If I already have the plaintext and i want to encrypt it.I also use the length argument in case I want later to use the length of the encrypted message because I can not use any other string manipulation command to get the size of the ciphertext since ciphertext do not end at the '\0'.The length of the final cipher was calculated with the p_len(plaintext length) and f_len in case the whole length of ciphertext was not multiple of BLOCK_SIZE.In that case f_len contained the final number of the block size and in that case ciphertext had a chance at the last 16 bytes to have a number of paddings.EVP_EncryptUpdate was used to fill the ciphertext buffer and EVP_EncryptUpdate was used in case there was padding.Since ciphertext size was beetween plaintext length or plaintext length + BLOCK_SIZE -1 the allocated memory for the ciphertext was plaintext_len+BLOCK_SIZE-1.

unsigned char * decrypt( unsigned char * ,char *,  char *, unsigned char *, 
    unsigned char *, int ,int ,int *):
This function wased for the decryption of the ciphertext.It is almost the same as the encrypt() function.The differences are that we use EVP_Decrypt() functions instead of EVP_Encrypt.Also at start we check if the ciphertext is given as an argument or as an input_file which we should read.Also the last two argumens(int ciphertext_len,int *decr_length) are used for the following reasons.By passing a ciphertext_len we can get the encrypted file size in case ciphertext is passed as argument and *decr_length is used in case we want to use the decrypted message length later since after we decrypt the message the decrypted plaintext does not contain '\0' character.

unsigned char * gen_cmac(unsigned char* ,unsigned char *,char *,char*,  unsigned char *, int,int);
int verify_cmac(unsigned char *, unsigned char *):
This function is used to get the plaintext and generate the cmac.If we use this function while we are signing then the ciphertext concatenated with the cmac is stored at an output file.If we use this function to verify then the cmac is returned so we can compare it with another cmac to check if they are the same.The lenCipher variable is used to encrypt the plaintext in case we concatenate the cmac and cipher to store it in an output file.

int verify_cmac(unsigned char *, unsigned char *):This function compares the two cmacs that are giver as arguments and if they are the same it returns 0 else it returns 1.

void before_verify_cmac(char *,char *,unsigned char* ,int):
This function is used to verify if an encrypted text must be verified when both sender and reviever know the key for encryption and decryption.Firstly using the memcpy() command I seperate the ciphertext from the cmac and store it in two buffers.After this I decrypt the plain message and creating the cmac for the plaintext in function gen_cmac().I return the cmac from this function and then using the verify_cmac() function I compare the two cmacs.If the function returns 0 it means that cmacs are the same  I write the plaintext in the output_file and print the message "CMAC VERIFIED".If CMACs are not the same I print CMAC NOT VERIFIED.

gcc --version: 
gcc (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0

Sources I used to help me implement the above functionalities:
https://www.openssl.org/docs/man1.1.1/man3/EVP_EncryptUpdate.html
https://cpp.hotexamples.com/examples/-/-/EVP_EncryptUpdate/cpp-evp_encryptupdate-function-examples.html
https://www.cs.ucy.ac.cy/courses/EPL326/labs/lab3/aesimplentation.pdf
https://man.openbsd.org/CMAC_Init.3
https://datatracker.ietf.org/doc/html/rfc4493

./assign_2 -b 128 -p hpy414 -i hpy414_verifyme_128.txt -v
